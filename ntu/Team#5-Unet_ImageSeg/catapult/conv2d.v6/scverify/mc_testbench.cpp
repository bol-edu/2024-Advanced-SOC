// ----------------------------------------------------------------------------
// SystemC Testbench Body
//
//    HLS version: 2023.2/1059873 Production Release
//       HLS date: Mon Aug  7 10:54:31 PDT 2023
//  Flow Packages: HDL_Tcl 8.0a, SCVerify 10.4
//
//   Generated by: r12016@cad40
// Generated date: Thu Jun 13 02:26:39 CST 2024
//
// ----------------------------------------------------------------------------
// 
// -------------------------------------
// mc_testbench
// SCVerify mc_testbench SC_MODULE
// -------------------------------------
// 
#include "mc_testbench.h"
#include <mc_testbench_util.h>
#include <mc_simulator_extensions.h>

mc_testbench* mc_testbench::that;
bool testbench::enable_idle_sync_mode;
unsigned short testbench::idle_sync_stable_cycles;
void testbench::set_enable_stalls(bool flag) { mc_testbench::set_enable_stalls(flag); }
void testbench::reset_request() { mc_testbench::that->reset_request(); }
void mc_testbench_reset_request() { mc_testbench::that->reset_request(); }
void* testbench::_dut_inst = NULL;
void* testbench::dut_inst() { return _dut_inst; }
void* mc_testbench_dut_inst() { return testbench::dut_inst(); }
void* testbench::set_dut_inst( void* _inst ) { if(_dut_inst==NULL) _dut_inst=_inst; return _dut_inst; }
void* mc_testbench_set_dut_inst( void* _inst ) { return testbench::set_dut_inst(_inst); }
void mc_testbench_wait_for_idle_sync() { mc_testbench::wait_for_idle_sync(); }
bool testbench::input_ignore;
void mc_testbench_input_skip(bool v) { testbench::input_skip = v; }
bool testbench::input_skip;
bool testbench::input_skip_quiet;
bool testbench::input_skip_once;
bool testbench::input_skip_noerr;
int  testbench::input_array_comp_first;
int  testbench::input_array_comp_last;
mc_wait_ctrl testbench::input_wait_ctrl;
bool testbench::padded_input_ignore;
void mc_testbench_padded_input_skip(bool v) { testbench::padded_input_skip = v; }
bool testbench::padded_input_skip;
bool testbench::padded_input_skip_quiet;
bool testbench::padded_input_skip_once;
bool testbench::padded_input_skip_noerr;
int  testbench::padded_input_array_comp_first;
int  testbench::padded_input_array_comp_last;
mc_wait_ctrl testbench::padded_input_IN_wait_ctrl;
bool testbench::padded_input_use_mask;
ac_fixed<12, 8, true, AC_TRN, AC_WRAP > testbench::padded_input_output_mask;
mc_wait_ctrl testbench::padded_input_wait_ctrl;
bool testbench::output_ignore;
void mc_testbench_output_skip(bool v) { testbench::output_skip = v; }
bool testbench::output_skip;
bool testbench::output_skip_quiet;
bool testbench::output_skip_once;
bool testbench::output_skip_noerr;
int  testbench::output_array_comp_first;
int  testbench::output_array_comp_last;
bool testbench::output_use_mask;
ac_fixed<12, 8, true, AC_TRN, AC_WRAP > testbench::output_output_mask;
mc_wait_ctrl testbench::output_wait_ctrl;
bool testbench::height_ignore;
void mc_testbench_height_skip(bool v) { testbench::height_skip = v; }
bool testbench::height_skip;
bool testbench::height_skip_quiet;
bool testbench::height_skip_once;
bool testbench::height_skip_noerr;
int  testbench::height_array_comp_first;
int  testbench::height_array_comp_last;
mc_wait_ctrl testbench::height_wait_ctrl;
bool testbench::width_ignore;
void mc_testbench_width_skip(bool v) { testbench::width_skip = v; }
bool testbench::width_skip;
bool testbench::width_skip_quiet;
bool testbench::width_skip_once;
bool testbench::width_skip_noerr;
int  testbench::width_array_comp_first;
int  testbench::width_array_comp_last;
mc_wait_ctrl testbench::width_wait_ctrl;
bool testbench::kernel_size_ignore;
void mc_testbench_kernel_size_skip(bool v) { testbench::kernel_size_skip = v; }
bool testbench::kernel_size_skip;
bool testbench::kernel_size_skip_quiet;
bool testbench::kernel_size_skip_once;
bool testbench::kernel_size_skip_noerr;
int  testbench::kernel_size_array_comp_first;
int  testbench::kernel_size_array_comp_last;
mc_wait_ctrl testbench::kernel_size_wait_ctrl;
bool testbench::padding_ignore;
void mc_testbench_padding_skip(bool v) { testbench::padding_skip = v; }
bool testbench::padding_skip;
bool testbench::padding_skip_quiet;
bool testbench::padding_skip_once;
bool testbench::padding_skip_noerr;
int  testbench::padding_array_comp_first;
int  testbench::padding_array_comp_last;
mc_wait_ctrl testbench::padding_wait_ctrl;
bool testbench::filter_offset_ignore;
void mc_testbench_filter_offset_skip(bool v) { testbench::filter_offset_skip = v; }
bool testbench::filter_offset_skip;
bool testbench::filter_offset_skip_quiet;
bool testbench::filter_offset_skip_once;
bool testbench::filter_offset_skip_noerr;
int  testbench::filter_offset_array_comp_first;
int  testbench::filter_offset_array_comp_last;
mc_wait_ctrl testbench::filter_offset_wait_ctrl;
bool testbench::in_channels_ignore;
void mc_testbench_in_channels_skip(bool v) { testbench::in_channels_skip = v; }
bool testbench::in_channels_skip;
bool testbench::in_channels_skip_quiet;
bool testbench::in_channels_skip_once;
bool testbench::in_channels_skip_noerr;
int  testbench::in_channels_array_comp_first;
int  testbench::in_channels_array_comp_last;
mc_wait_ctrl testbench::in_channels_wait_ctrl;
bool testbench::out_channels_ignore;
void mc_testbench_out_channels_skip(bool v) { testbench::out_channels_skip = v; }
bool testbench::out_channels_skip;
bool testbench::out_channels_skip_quiet;
bool testbench::out_channels_skip_once;
bool testbench::out_channels_skip_noerr;
int  testbench::out_channels_array_comp_first;
int  testbench::out_channels_array_comp_last;
mc_wait_ctrl testbench::out_channels_wait_ctrl;
#ifndef CCS_SCVERIFY_USE_CCS_BLOCK
void testbench::exec_run_conv(ac_fixed<12, 8, true, AC_TRN, AC_WRAP> input[32768], ac_fixed<12, 8, true, AC_TRN, AC_WRAP> padded_input[34848], ac_fixed<12, 8, true, AC_TRN, AC_WRAP> output[32768], ac_int<7, false> &height, ac_int<7, false> &width, ac_int<2, false> &kernel_size, ac_int<2, false> &padding, ac_int<20, false> &filter_offset, ac_int<7, false> &in_channels, ac_int<7, false> &out_channels) {
   return mc_testbench::exec_run_conv(input, padded_input, output, height, width, kernel_size, padding, filter_offset, in_channels, out_channels);
}
#endif

// ============================================
// Function: wait_for_idle_sync
// --------------------------------------------

void mc_testbench::wait_for_idle_sync()
{
   if (testbench::enable_idle_sync_mode) {
     std::cout << "mc_testbench: Idle synchronization disabled, requires design with stall controls." << std::endl;
     testbench::enable_idle_sync_mode = false;
     that->cpp_testbench_active.write(true);
   }
}
// ============================================
// Function: set_enable_stalls
// --------------------------------------------

void mc_testbench::set_enable_stalls(bool flag)
{
   if (flag) {
     std::cout << "Enabling STALL_FLAG toggling" << std::endl;
     that->enable_stalls.write(sc_dt::Log_1);
   } else {
     std::cout << "Disabling STALL_FLAG toggling" << std::endl;
     that->enable_stalls.write(sc_dt::Log_0);
   }
}
// ============================================
// Function: reset_request
// --------------------------------------------

void mc_testbench::reset_request()
{
   reset_request_event.notify(0,SC_NS);
}
// ============================================
// Function: capture_input
// --------------------------------------------

void mc_testbench::capture_input( ac_fixed<12, 8, true, AC_TRN, AC_WRAP > input[32768])
{
   if (input_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_input && !testbench::input_ignore)
   {
      int cur_iter = input_iteration_count;
      ++input_iteration_count;
      mgc_sysc_ver_array1D<ac_fixed<12, 8, true, AC_TRN, AC_WRAP >,32768> input_tmp;
      int input_linear_idx = 0;
      for (int input_idx_0 = 0; input_idx_0 < 32768; ++input_idx_0)
         input_tmp[input_linear_idx++] = input[input_idx_0];
      ccs_input->put(input_tmp);
      ++input_capture_count;
      mc_testbench_util::process_wait_ctrl("input",testbench::input_wait_ctrl,ccs_wait_ctrl_input.operator->(),cur_iter,input_capture_count,0);
   }
   testbench::input_ignore = false;
}
// ============================================
// Function: capture_padded_input_IN
// --------------------------------------------

void mc_testbench::capture_padded_input_IN( ac_fixed<12, 8, true, AC_TRN, AC_WRAP > padded_input[34848])
{
   if (padded_input_IN_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_padded_input_IN && !testbench::padded_input_ignore)
   {
      int cur_iter = padded_input_IN_iteration_count;
      ++padded_input_IN_iteration_count;
      mgc_sysc_ver_array1D<ac_fixed<12, 8, true, AC_TRN, AC_WRAP >,34848> padded_input_IN_tmp;
      int padded_input_linear_idx = 0;
      for (int padded_input_idx_0 = 0; padded_input_idx_0 < 34848; ++padded_input_idx_0)
         padded_input_IN_tmp[padded_input_linear_idx++] = padded_input[padded_input_idx_0];
      ccs_padded_input_IN->put(padded_input_IN_tmp);
      ++padded_input_IN_capture_count;
      mc_testbench_util::process_wait_ctrl("padded_input_IN",testbench::padded_input_IN_wait_ctrl,ccs_wait_ctrl_padded_input_IN.operator->(),cur_iter,padded_input_IN_capture_count,0);
   }
   testbench::padded_input_ignore = false;
}
// ============================================
// Function: capture_padded_input
// --------------------------------------------

void mc_testbench::capture_padded_input( ac_fixed<12, 8, true, AC_TRN, AC_WRAP > padded_input[34848])
{
   if (_capture_padded_input)
   {
      int cur_iter = padded_input_iteration_count;
      ++padded_input_iteration_count;
      mc_golden_info< mgc_sysc_ver_array1D<ac_fixed<12, 8, true, AC_TRN, AC_WRAP >,34848>, MaskPacket<0, 12> > padded_input_tmp(testbench::padded_input_ignore, false, padded_input_iteration_count);
      padded_input_tmp._data.mc_testbench_process_array_bounds("padded_input",testbench::padded_input_array_comp_first,testbench::padded_input_array_comp_last,34847,0);
      // BEGIN: testbench output_mask control for field_name padded_input
      if ( testbench::padded_input_use_mask ) {
         sc_lv<12> tmp_mask_lv;
         type_to_vector(testbench::padded_input_output_mask, 12, tmp_mask_lv);
         padded_input_tmp._use_mask = true;
         padded_input_tmp._packet._mask = tmp_mask_lv;
      }
      // END: testbench output_mask control for field_name padded_input
      int padded_input_linear_idx = 0;
      for (int padded_input_idx_0 = 0; padded_input_idx_0 < 34848; ++padded_input_idx_0)
         padded_input_tmp._data[padded_input_linear_idx++] = padded_input[padded_input_idx_0];
      if (!testbench::padded_input_skip) {
         padded_input_golden.put(padded_input_tmp);
         ++padded_input_capture_count;
      } else {
         if (!testbench::padded_input_skip_quiet || !testbench::padded_input_skip_once) {
            std::ostringstream msg; msg.str("");
            msg << "testbench::padded_input_skip=true for iteration=" << padded_input_iteration_count << " @ " << sc_time_stamp();
            SC_REPORT_WARNING("User testbench", msg.str().c_str());
            testbench::padded_input_skip_once = true;
         }
      }
      mc_testbench_util::process_wait_ctrl("padded_input",testbench::padded_input_wait_ctrl,ccs_wait_ctrl_padded_input.operator->(),cur_iter,padded_input_capture_count,0);
      testbench::padded_input_use_mask = false;
   }
   testbench::padded_input_ignore = false;
   testbench::padded_input_skip = false;
}
// ============================================
// Function: capture_output
// --------------------------------------------

void mc_testbench::capture_output( ac_fixed<12, 8, true, AC_TRN, AC_WRAP > output[32768])
{
   if (_capture_output)
   {
      int cur_iter = output_iteration_count;
      ++output_iteration_count;
      mc_golden_info< mgc_sysc_ver_array1D<ac_fixed<12, 8, true, AC_TRN, AC_WRAP >,32768>, MaskPacket<0, 12> > output_tmp(testbench::output_ignore, false, output_iteration_count);
      output_tmp._data.mc_testbench_process_array_bounds("output",testbench::output_array_comp_first,testbench::output_array_comp_last,32767,0);
      // BEGIN: testbench output_mask control for field_name output
      if ( testbench::output_use_mask ) {
         sc_lv<12> tmp_mask_lv;
         type_to_vector(testbench::output_output_mask, 12, tmp_mask_lv);
         output_tmp._use_mask = true;
         output_tmp._packet._mask = tmp_mask_lv;
      }
      // END: testbench output_mask control for field_name output
      int output_linear_idx = 0;
      for (int output_idx_0 = 0; output_idx_0 < 32768; ++output_idx_0)
         output_tmp._data[output_linear_idx++] = output[output_idx_0];
      if (!testbench::output_skip) {
         output_golden.put(output_tmp);
         ++output_capture_count;
      } else {
         if (!testbench::output_skip_quiet || !testbench::output_skip_once) {
            std::ostringstream msg; msg.str("");
            msg << "testbench::output_skip=true for iteration=" << output_iteration_count << " @ " << sc_time_stamp();
            SC_REPORT_WARNING("User testbench", msg.str().c_str());
            testbench::output_skip_once = true;
         }
      }
      mc_testbench_util::process_wait_ctrl("output",testbench::output_wait_ctrl,ccs_wait_ctrl_output.operator->(),cur_iter,output_capture_count,0);
      testbench::output_use_mask = false;
   }
   testbench::output_ignore = false;
   testbench::output_skip = false;
}
// ============================================
// Function: capture_height
// --------------------------------------------

void mc_testbench::capture_height( ac_int<7, false > &height)
{
   if (height_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_height && !testbench::height_ignore)
   {
      int cur_iter = height_iteration_count;
      ++height_iteration_count;
      ccs_height->nb_put(height); // THIS
      ++height_capture_count;
      if (height_iteration_count > 1 && !height_mismatch && height_prev_value != height)
         height_mismatch = true;
      height_prev_value = height;
      if (!testbench::enable_idle_sync_mode && height_mismatch && height_idle_warning) {
         height_idle_warning = false;
         std::ostringstream msg; msg.str("");
         msg << "Direct input \"height\" had its value changed between design function calls with idle synchronization disabled.\n";
         msg << "Warning:  Potential simulation mismatch detected. Consider setting \"IDLE_SYNCHRONIZATION_MODE\" to true in the SCVerify flow.\n";
         msg << "Warning:  Further warnings for this direct input will be suppressed.";
         SC_REPORT_WARNING("User testbench", msg.str().c_str());
      }
      mc_testbench_util::process_wait_ctrl("height",testbench::height_wait_ctrl,ccs_wait_ctrl_height.operator->(),cur_iter,height_capture_count,0);
   }
   testbench::height_ignore = false;
}
// ============================================
// Function: capture_width
// --------------------------------------------

void mc_testbench::capture_width( ac_int<7, false > &width)
{
   if (width_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_width && !testbench::width_ignore)
   {
      int cur_iter = width_iteration_count;
      ++width_iteration_count;
      ccs_width->nb_put(width); // THIS
      ++width_capture_count;
      if (width_iteration_count > 1 && !width_mismatch && width_prev_value != width)
         width_mismatch = true;
      width_prev_value = width;
      if (!testbench::enable_idle_sync_mode && width_mismatch && width_idle_warning) {
         width_idle_warning = false;
         std::ostringstream msg; msg.str("");
         msg << "Direct input \"width\" had its value changed between design function calls with idle synchronization disabled.\n";
         msg << "Warning:  Potential simulation mismatch detected. Consider setting \"IDLE_SYNCHRONIZATION_MODE\" to true in the SCVerify flow.\n";
         msg << "Warning:  Further warnings for this direct input will be suppressed.";
         SC_REPORT_WARNING("User testbench", msg.str().c_str());
      }
      mc_testbench_util::process_wait_ctrl("width",testbench::width_wait_ctrl,ccs_wait_ctrl_width.operator->(),cur_iter,width_capture_count,0);
   }
   testbench::width_ignore = false;
}
// ============================================
// Function: capture_kernel_size
// --------------------------------------------

void mc_testbench::capture_kernel_size( ac_int<2, false > &kernel_size)
{
   if (kernel_size_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_kernel_size && !testbench::kernel_size_ignore)
   {
      int cur_iter = kernel_size_iteration_count;
      ++kernel_size_iteration_count;
      ccs_kernel_size->nb_put(kernel_size); // THIS
      ++kernel_size_capture_count;
      if (kernel_size_iteration_count > 1 && !kernel_size_mismatch && kernel_size_prev_value != kernel_size)
         kernel_size_mismatch = true;
      kernel_size_prev_value = kernel_size;
      if (!testbench::enable_idle_sync_mode && kernel_size_mismatch && kernel_size_idle_warning) {
         kernel_size_idle_warning = false;
         std::ostringstream msg; msg.str("");
         msg << "Direct input \"kernel_size\" had its value changed between design function calls with idle synchronization disabled.\n";
         msg << "Warning:  Potential simulation mismatch detected. Consider setting \"IDLE_SYNCHRONIZATION_MODE\" to true in the SCVerify flow.\n";
         msg << "Warning:  Further warnings for this direct input will be suppressed.";
         SC_REPORT_WARNING("User testbench", msg.str().c_str());
      }
      mc_testbench_util::process_wait_ctrl("kernel_size",testbench::kernel_size_wait_ctrl,ccs_wait_ctrl_kernel_size.operator->(),cur_iter,kernel_size_capture_count,0);
   }
   testbench::kernel_size_ignore = false;
}
// ============================================
// Function: capture_padding
// --------------------------------------------

void mc_testbench::capture_padding( ac_int<2, false > &padding)
{
   if (padding_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_padding && !testbench::padding_ignore)
   {
      int cur_iter = padding_iteration_count;
      ++padding_iteration_count;
      ccs_padding->nb_put(padding); // THIS
      ++padding_capture_count;
      if (padding_iteration_count > 1 && !padding_mismatch && padding_prev_value != padding)
         padding_mismatch = true;
      padding_prev_value = padding;
      if (!testbench::enable_idle_sync_mode && padding_mismatch && padding_idle_warning) {
         padding_idle_warning = false;
         std::ostringstream msg; msg.str("");
         msg << "Direct input \"padding\" had its value changed between design function calls with idle synchronization disabled.\n";
         msg << "Warning:  Potential simulation mismatch detected. Consider setting \"IDLE_SYNCHRONIZATION_MODE\" to true in the SCVerify flow.\n";
         msg << "Warning:  Further warnings for this direct input will be suppressed.";
         SC_REPORT_WARNING("User testbench", msg.str().c_str());
      }
      mc_testbench_util::process_wait_ctrl("padding",testbench::padding_wait_ctrl,ccs_wait_ctrl_padding.operator->(),cur_iter,padding_capture_count,0);
   }
   testbench::padding_ignore = false;
}
// ============================================
// Function: capture_filter_offset
// --------------------------------------------

void mc_testbench::capture_filter_offset( ac_int<20, false > &filter_offset)
{
   if (filter_offset_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_filter_offset && !testbench::filter_offset_ignore)
   {
      int cur_iter = filter_offset_iteration_count;
      ++filter_offset_iteration_count;
      ccs_filter_offset->nb_put(filter_offset); // THIS
      ++filter_offset_capture_count;
      if (filter_offset_iteration_count > 1 && !filter_offset_mismatch && filter_offset_prev_value != filter_offset)
         filter_offset_mismatch = true;
      filter_offset_prev_value = filter_offset;
      if (!testbench::enable_idle_sync_mode && filter_offset_mismatch && filter_offset_idle_warning) {
         filter_offset_idle_warning = false;
         std::ostringstream msg; msg.str("");
         msg << "Direct input \"filter_offset\" had its value changed between design function calls with idle synchronization disabled.\n";
         msg << "Warning:  Potential simulation mismatch detected. Consider setting \"IDLE_SYNCHRONIZATION_MODE\" to true in the SCVerify flow.\n";
         msg << "Warning:  Further warnings for this direct input will be suppressed.";
         SC_REPORT_WARNING("User testbench", msg.str().c_str());
      }
      mc_testbench_util::process_wait_ctrl("filter_offset",testbench::filter_offset_wait_ctrl,ccs_wait_ctrl_filter_offset.operator->(),cur_iter,filter_offset_capture_count,0);
   }
   testbench::filter_offset_ignore = false;
}
// ============================================
// Function: capture_in_channels
// --------------------------------------------

void mc_testbench::capture_in_channels( ac_int<7, false > &in_channels)
{
   if (in_channels_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_in_channels && !testbench::in_channels_ignore)
   {
      int cur_iter = in_channels_iteration_count;
      ++in_channels_iteration_count;
      ccs_in_channels->nb_put(in_channels); // THIS
      ++in_channels_capture_count;
      if (in_channels_iteration_count > 1 && !in_channels_mismatch && in_channels_prev_value != in_channels)
         in_channels_mismatch = true;
      in_channels_prev_value = in_channels;
      if (!testbench::enable_idle_sync_mode && in_channels_mismatch && in_channels_idle_warning) {
         in_channels_idle_warning = false;
         std::ostringstream msg; msg.str("");
         msg << "Direct input \"in_channels\" had its value changed between design function calls with idle synchronization disabled.\n";
         msg << "Warning:  Potential simulation mismatch detected. Consider setting \"IDLE_SYNCHRONIZATION_MODE\" to true in the SCVerify flow.\n";
         msg << "Warning:  Further warnings for this direct input will be suppressed.";
         SC_REPORT_WARNING("User testbench", msg.str().c_str());
      }
      mc_testbench_util::process_wait_ctrl("in_channels",testbench::in_channels_wait_ctrl,ccs_wait_ctrl_in_channels.operator->(),cur_iter,in_channels_capture_count,0);
   }
   testbench::in_channels_ignore = false;
}
// ============================================
// Function: capture_out_channels
// --------------------------------------------

void mc_testbench::capture_out_channels( ac_int<7, false > &out_channels)
{
   if (out_channels_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_out_channels && !testbench::out_channels_ignore)
   {
      int cur_iter = out_channels_iteration_count;
      ++out_channels_iteration_count;
      ccs_out_channels->nb_put(out_channels); // THIS
      ++out_channels_capture_count;
      if (out_channels_iteration_count > 1 && !out_channels_mismatch && out_channels_prev_value != out_channels)
         out_channels_mismatch = true;
      out_channels_prev_value = out_channels;
      if (!testbench::enable_idle_sync_mode && out_channels_mismatch && out_channels_idle_warning) {
         out_channels_idle_warning = false;
         std::ostringstream msg; msg.str("");
         msg << "Direct input \"out_channels\" had its value changed between design function calls with idle synchronization disabled.\n";
         msg << "Warning:  Potential simulation mismatch detected. Consider setting \"IDLE_SYNCHRONIZATION_MODE\" to true in the SCVerify flow.\n";
         msg << "Warning:  Further warnings for this direct input will be suppressed.";
         SC_REPORT_WARNING("User testbench", msg.str().c_str());
      }
      mc_testbench_util::process_wait_ctrl("out_channels",testbench::out_channels_wait_ctrl,ccs_wait_ctrl_out_channels.operator->(),cur_iter,out_channels_capture_count,0);
   }
   testbench::out_channels_ignore = false;
}
// ============================================
// Function: wait_on_input_required
// --------------------------------------------

void mc_testbench::wait_on_input_required()
{
   ++wait_cnt;
   wait(SC_ZERO_TIME); // get fifos a chance to update
   ++period_counter;
   sc_time timeout = sc_time_stamp() - previous_timestamp;
   if (calculate_period && sc_time_stamp() > SC_ZERO_TIME && sc_time_stamp() != previous_timestamp && sc_time_stamp() != timeout) {
      average_period = (average_period + timeout) / 2;
   }
   previous_timestamp = sc_time_stamp();
   while (atleast_one_active_input) {
      if (_capture_input && ccs_input->used() == 0) return;
      if (_capture_padded_input_IN && ccs_padded_input_IN->used() == 0) return;
      that->cpp_testbench_active.write(false);
      if (average_period > SC_ZERO_TIME && sc_time_stamp() != timeout)
         wait(average_period * 10, ccs_input->ok_to_put() | ccs_padded_input_IN->ok_to_put());
      else
         wait(ccs_input->ok_to_put() | ccs_padded_input_IN->ok_to_put());
      that->cpp_testbench_active.write(true);
      if (timed_out()) {
         calculate_period = false;
         return;
      }
   }
}
// ============================================
// Function: capture_IN
// --------------------------------------------

void mc_testbench::capture_IN(ac_fixed<12, 8, true, AC_TRN, AC_WRAP> input[32768], ac_fixed<12, 8, true, AC_TRN, AC_WRAP> padded_input[34848], ac_fixed<12, 8, true, AC_TRN, AC_WRAP> output[32768], ac_int<7, false> &height, ac_int<7, false> &width, ac_int<2, false> &kernel_size, ac_int<2, false> &padding, ac_int<20, false> &filter_offset, ac_int<7, false> &in_channels, ac_int<7, false> &out_channels)
{
   that->capture_input(input);
   that->capture_padded_input_IN(padded_input);
   that->capture_height(height);
   that->capture_width(width);
   that->capture_kernel_size(kernel_size);
   that->capture_padding(padding);
   that->capture_filter_offset(filter_offset);
   that->capture_in_channels(in_channels);
   that->capture_out_channels(out_channels);
}
// ============================================
// Function: capture_OUT
// --------------------------------------------

void mc_testbench::capture_OUT(ac_fixed<12, 8, true, AC_TRN, AC_WRAP> input[32768], ac_fixed<12, 8, true, AC_TRN, AC_WRAP> padded_input[34848], ac_fixed<12, 8, true, AC_TRN, AC_WRAP> output[32768], ac_int<7, false> &height, ac_int<7, false> &width, ac_int<2, false> &kernel_size, ac_int<2, false> &padding, ac_int<20, false> &filter_offset, ac_int<7, false> &in_channels, ac_int<7, false> &out_channels)
{
   that->capture_padded_input(padded_input);
   that->capture_output(output);
}
// ============================================
// Function: exec_run_conv
// --------------------------------------------

void mc_testbench::exec_run_conv(ac_fixed<12, 8, true, AC_TRN, AC_WRAP> input[32768], ac_fixed<12, 8, true, AC_TRN, AC_WRAP> padded_input[34848], ac_fixed<12, 8, true, AC_TRN, AC_WRAP> output[32768], ac_int<7, false> &height, ac_int<7, false> &width, ac_int<2, false> &kernel_size, ac_int<2, false> &padding, ac_int<20, false> &filter_offset, ac_int<7, false> &in_channels, ac_int<7, false> &out_channels)
{
   #ifndef CCS_SCVERIFY_USE_CCS_BLOCK
   wait_for_idle_sync();
   capture_IN(input, padded_input, output, height, width, kernel_size, padding, filter_offset, in_channels, out_channels);
   UNET_IP::conv2d::run_conv(input, padded_input, output, height, width, kernel_size, padding, filter_offset, in_channels, out_channels);
   // throttle ac_channel based on number of calls to chan::size() or chan::empty() or chan::nb_read() (but not chan::available()) 
   if (1) {
      int cnt=0;
      if (cnt) std::cout << "mc_testbench.cpp: CONTINUES @ " << sc_time_stamp() << std::endl;
      if (cnt) that->cpp_testbench_active.write(true);
   }
   capture_OUT(input, padded_input, output, height, width, kernel_size, padding, filter_offset, in_channels, out_channels);
   #else
   #endif
}
// ============================================
// Function: start_of_simulation
// --------------------------------------------

void mc_testbench::start_of_simulation()
{
   set_enable_stalls(false);
   if (ac_env::read_int("SCVerify_AUTOWAIT", 0) != 0) { //explicitly 0 means off
      SC_REPORT_INFO(name(), "SCVerify AUTOWAIT is enabled for this simulation.");
   }
}
// ============================================
// Function: end_of_simulation
// --------------------------------------------

void mc_testbench::end_of_simulation()
{
   if (!_checked_results) {
      SC_REPORT_INFO(name(), "Testbench exited early or ran into deadlock");
      check_results();
   }
}
// ============================================
// Function: check_results
// --------------------------------------------

void mc_testbench::check_results()
{
   if (_checked_results) return;
   _checked_results = true;
   cout<<endl;
   cout<<"Checking results"<<endl;
   if (main_exit_code) _failed = true;
   int _num_outputs_checked = 0;
   bool _has_capture_counts = false;
   std::ostringstream mctb_msg;
   
   if (!_capture_padded_input) {
      cout<<"'padded_input' - warning, output was optimized away"<<endl;
   } else {
      _num_outputs_checked++;
      _failed |= padded_input_comp->check_results(padded_input_capture_count,testbench::padded_input_skip_noerr);
      _has_capture_counts |= !!(padded_input_capture_count);
   }
   if (!_capture_output) {
      cout<<"'output' - warning, output was optimized away"<<endl;
   } else {
      _num_outputs_checked++;
      _failed |= output_comp->check_results(output_capture_count,testbench::output_skip_noerr);
      _has_capture_counts |= !!(output_capture_count);
   }
   cout<<endl;
   if (_num_outputs_checked == 0) {
      cout<<"Error: All outputs were optimized away. No output values were compared."<<endl;
      _failed = _failed || (_num_outputs_checked == 0);
   }
   if (!_has_capture_counts) {
      cout<<"Error: Nothing to compare, all output capture counts are zero."<<endl;
      _failed = true;
   }
   if (main_exit_code) cout << "Error: C++ Testbench 'main()' returned a non-zero exit code ("<<main_exit_code<<"). Check your testbench." <<endl;
   mctb_msg.clear();
   if (_failed) mctb_msg << "Simulation FAILED";
   else         mctb_msg << "Simulation PASSED";
   mctb_msg << " @ " << sc_time_stamp();
   if (_channel_mismatch && _failed)
      mctb_msg << endl << "An input channel was switched before the input fifo was fully empty. Check your testbench.";
   SC_REPORT_INFO(this->name(), mctb_msg.str().c_str());
}
// ============================================
// Function: failed
// --------------------------------------------

bool mc_testbench::failed()
{
   return _failed;
}
// ============================================
// Function: set_failed
// --------------------------------------------

void mc_testbench::set_failed(bool fail)
{
   _failed = fail;
}
// ---------------------------------------------------------------
// Process: SC_METHOD wait_for_end
// Static sensitivity: sensitive << clk.pos() << testbench_end_event;

void mc_testbench::wait_for_end() {
   // If run() has not finished, we do nothing here
   if (!testbench_ended) return;
   // check for completed outputs
   if (padded_input_comp->get_compare_count() < padded_input_capture_count) {testbench_end_event.notify(1,SC_NS); return;}
   if (output_comp->get_compare_count() < output_capture_count) {testbench_end_event.notify(1,SC_NS); return;}
   // If we made it here, all outputs have flushed. Check the results
   testbench_aw_event.notify(SC_ZERO_TIME);
   SC_REPORT_INFO(name(), "Simulation completed");
   check_results();
   sc_stop();
}
// ---------------------------------------------------------------
// Process: SC_THREAD run
// Static sensitivity: 

void mc_testbench::run() {
   testbench::enable_idle_sync_mode = false;
   testbench::idle_sync_stable_cycles = 1;
   _channel_mismatch = false;
   testbench::input_ignore = false;
   testbench::input_skip = false;
   testbench::input_skip_quiet = false;
   testbench::input_skip_once = false;
   testbench::input_skip_noerr = false;
   testbench::input_array_comp_first = -1;
   testbench::input_array_comp_last = -1;
   testbench::input_wait_ctrl.clear();
   input_capture_count = 0;
   input_iteration_count = 0;
   testbench::padded_input_ignore = false;
   testbench::padded_input_skip = false;
   testbench::padded_input_skip_quiet = false;
   testbench::padded_input_skip_once = false;
   testbench::padded_input_skip_noerr = false;
   testbench::padded_input_array_comp_first = -1;
   testbench::padded_input_array_comp_last = -1;
   testbench::padded_input_IN_wait_ctrl.clear();
   padded_input_IN_capture_count = 0;
   padded_input_IN_iteration_count = 0;
   testbench::padded_input_use_mask = false;
   testbench::padded_input_output_mask = (ac_fixed<12, 8, true, AC_TRN, AC_WRAP >) ~0;
   testbench::padded_input_wait_ctrl.clear();
   padded_input_capture_count = 0;
   padded_input_iteration_count = 0;
   testbench::output_ignore = false;
   testbench::output_skip = false;
   testbench::output_skip_quiet = false;
   testbench::output_skip_once = false;
   testbench::output_skip_noerr = false;
   testbench::output_array_comp_first = -1;
   testbench::output_array_comp_last = -1;
   testbench::output_use_mask = false;
   testbench::output_output_mask = (ac_fixed<12, 8, true, AC_TRN, AC_WRAP >) ~0;
   testbench::output_wait_ctrl.clear();
   output_capture_count = 0;
   output_iteration_count = 0;
   testbench::height_ignore = false;
   testbench::height_skip = false;
   testbench::height_skip_quiet = false;
   testbench::height_skip_once = false;
   testbench::height_skip_noerr = false;
   testbench::height_array_comp_first = -1;
   testbench::height_array_comp_last = -1;
   testbench::height_wait_ctrl.clear();
   height_capture_count = 0;
   height_iteration_count = 0;
   height_idle_warning = true;
   height_mismatch = false;
   testbench::width_ignore = false;
   testbench::width_skip = false;
   testbench::width_skip_quiet = false;
   testbench::width_skip_once = false;
   testbench::width_skip_noerr = false;
   testbench::width_array_comp_first = -1;
   testbench::width_array_comp_last = -1;
   testbench::width_wait_ctrl.clear();
   width_capture_count = 0;
   width_iteration_count = 0;
   width_idle_warning = true;
   width_mismatch = false;
   testbench::kernel_size_ignore = false;
   testbench::kernel_size_skip = false;
   testbench::kernel_size_skip_quiet = false;
   testbench::kernel_size_skip_once = false;
   testbench::kernel_size_skip_noerr = false;
   testbench::kernel_size_array_comp_first = -1;
   testbench::kernel_size_array_comp_last = -1;
   testbench::kernel_size_wait_ctrl.clear();
   kernel_size_capture_count = 0;
   kernel_size_iteration_count = 0;
   kernel_size_idle_warning = true;
   kernel_size_mismatch = false;
   testbench::padding_ignore = false;
   testbench::padding_skip = false;
   testbench::padding_skip_quiet = false;
   testbench::padding_skip_once = false;
   testbench::padding_skip_noerr = false;
   testbench::padding_array_comp_first = -1;
   testbench::padding_array_comp_last = -1;
   testbench::padding_wait_ctrl.clear();
   padding_capture_count = 0;
   padding_iteration_count = 0;
   padding_idle_warning = true;
   padding_mismatch = false;
   testbench::filter_offset_ignore = false;
   testbench::filter_offset_skip = false;
   testbench::filter_offset_skip_quiet = false;
   testbench::filter_offset_skip_once = false;
   testbench::filter_offset_skip_noerr = false;
   testbench::filter_offset_array_comp_first = -1;
   testbench::filter_offset_array_comp_last = -1;
   testbench::filter_offset_wait_ctrl.clear();
   filter_offset_capture_count = 0;
   filter_offset_iteration_count = 0;
   filter_offset_idle_warning = true;
   filter_offset_mismatch = false;
   testbench::in_channels_ignore = false;
   testbench::in_channels_skip = false;
   testbench::in_channels_skip_quiet = false;
   testbench::in_channels_skip_once = false;
   testbench::in_channels_skip_noerr = false;
   testbench::in_channels_array_comp_first = -1;
   testbench::in_channels_array_comp_last = -1;
   testbench::in_channels_wait_ctrl.clear();
   in_channels_capture_count = 0;
   in_channels_iteration_count = 0;
   in_channels_idle_warning = true;
   in_channels_mismatch = false;
   testbench::out_channels_ignore = false;
   testbench::out_channels_skip = false;
   testbench::out_channels_skip_quiet = false;
   testbench::out_channels_skip_once = false;
   testbench::out_channels_skip_noerr = false;
   testbench::out_channels_array_comp_first = -1;
   testbench::out_channels_array_comp_last = -1;
   testbench::out_channels_wait_ctrl.clear();
   out_channels_capture_count = 0;
   out_channels_iteration_count = 0;
   out_channels_idle_warning = true;
   out_channels_mismatch = false;
   testbench testbench_inst(sc_argc(), sc_argv());
   main_exit_code = testbench_inst.main();
   cout<<"Info: Execution of user-supplied C++ testbench 'main()' has completed with exit code = " << main_exit_code << endl;
   cout<<endl;
   cout<<"Info: Collecting data completed"<<endl;
   cout<<"   captured "<<input_capture_count<<" values of input"<<endl;
   cout<<"   captured "<<padded_input_IN_capture_count<<" values of padded_input_IN"<<endl;
   cout<<"   captured "<<padded_input_capture_count<<" values of padded_input"<<endl;
   cout<<"   captured "<<output_capture_count<<" values of output"<<endl;
   cout<<"   captured "<<height_capture_count<<" values of height"<<endl;
   cout<<"   captured "<<width_capture_count<<" values of width"<<endl;
   cout<<"   captured "<<kernel_size_capture_count<<" values of kernel_size"<<endl;
   cout<<"   captured "<<padding_capture_count<<" values of padding"<<endl;
   cout<<"   captured "<<filter_offset_capture_count<<" values of filter_offset"<<endl;
   cout<<"   captured "<<in_channels_capture_count<<" values of in_channels"<<endl;
   cout<<"   captured "<<out_channels_capture_count<<" values of out_channels"<<endl;
   testbench_ended = true;
   testbench_end_event.notify(SC_ZERO_TIME);
}
#ifdef CCS_SCVERIFY_USE_CCS_BLOCK
#include "ccs_block_macros.cpp"
#endif
